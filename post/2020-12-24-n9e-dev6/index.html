<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    

    <title>夜莺二次开发指南-任务执行中心 | 秦叶宁的网志</title>
    <meta property="og:title" content="夜莺二次开发指南-任务执行中心 - 秦叶宁的网志">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2021-01-13T19:00:56&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2021-01-13T19:00:56&#43;08:00'>
        
    <meta name="Keywords" content="golang monitor aiops">
    <meta name="description" content="夜莺二次开发指南-任务执行中心">
        
    <meta name="author" content="秦叶宁">
    <meta property="og:url" content="http://www.qinyening.com/post/2020-12-24-n9e-dev6/">
    <link rel="shortcut icon" href='http://blog-1255977231.cos.ap-beijing.myqcloud.com/151300.jpg'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?62edf66253cb0df3cc6c28c802e8bf1f";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
    
    
    
    
    
        <link rel="stylesheet" href='/css/douban.css'>
    
        <link rel="stylesheet" href='/css/other.css'>
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://www.qinyening.com/">
                        秦叶宁的网志
                    </a>
                
                <p class="description">专注于可观测性、AIOps</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://www.qinyening.com/">首页</a>
                    
                    <a  href="http://www.qinyening.com/archives/" title="归档">归档</a>
                    
                    <a  href="http://www.qinyening.com/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">夜莺二次开发指南-任务执行中心</h1>
        </header>
        
        <date class="post-meta meta-date">
            2021年1月13日
        </date>
        
        
        
        
        <div class="post-content">
            <h3 id="前言">前言</h3>
<p>本系列将对夜莺平台各个模块的主要逻辑进行介绍，方便大家进行二次开发，本篇是系列的第六篇，任务执行中心 (JOB) 模块</p>
<p>首先贴下夜莺的项目地址和架构图，正在使用夜莺的读者欢迎给夜莺加一个star</p>
<ul>
<li>github地址 <a href="https://github.com/didi/nightingale">https://github.com/didi/nightingale</a></li>
<li>v3.0架构图如下</li>
</ul>
<p>
        <img class="mx-auto" alt="img" src="https://static001.geekbang.org/infoq/07/0722fd1f389e572364e00bea036b5eff.png" />   
    </p>
<p>本节主要讲解任务执行中心 JOB 模块，本篇主要讲解 JOB 模块的主要设计思路，以及如何基于job平台，开发自己的发布系统。</p>
<h3 id="设计思路">设计思路</h3>
<p>任务执行中心的功能由 agent 和 job 两个模块来实现。任务执行中心可以同时在上万台机器上执行任务，同时还要保证任务可以正常执行，不会重复执行。下面我们从几个问题入手，来帮助大家理解 job 是如何完成上述的工作的。</p>
<p><strong>1.如何支撑千万级别的任务分发和执行？</strong></p>
<p>为了支撑海量的任务，job 模块不能是一个单点，这样这样会遇到性能瓶颈，需要是多个实例，多个实例的话，就涉及到了任务调度，哪些任务由哪个实例去分配。下面介绍一下任务的调度逻辑，首先看一下任务是如何调度到不同的实例上去的，job 模块设计了一个 task_scheduler 的表，有 id 和 scheduler 两个字段，当每一个 job 实例启动的时候，都会去查询 scheduler 为空的数据，然后去接管任务，因为 mysql update 操作是有锁的，所以一个任务可以保证只会被一个 job 实例接管处理，这样就解决了调度问题和扩展问题，当 job 模块遇到性能瓶颈时，直接增加新的job实例即可，下面代码是具体的实现。</p>
<pre tabindex="0"><code>//获取没被认领的任务
func OrphanTaskIds() ([]int64, error) {
    var ids []int64
    err := DB[&#34;job&#34;].Table(&#34;task_scheduler&#34;).Where(&#34;scheduler = &#39;&#39;&#34;).Select(&#34;id&#34;).Find(&amp;ids)
    return ids, err
}

//尝试去接管任务
func TakeOverTask(id int64, pre, current string) (bool, error) {
    ret, err := DB[&#34;job&#34;].Exec(&#34;UPDATE task_scheduler SET scheduler=? WHERE id = ? and scheduler = ?&#34;, current, id, pre)
    if err != nil {
        return false, err
    }

    affected, err := ret.RowsAffected()
    if err != nil {
        return false, err
    }

    return affected &gt; 0, nil
}
</code></pre><p><strong>2.当某个 job 实例异常挂了之后，刚接管还没有下发的任务会不会永远不会执行，如果处理？</strong></p>
<p>job 模块会定期上报自己的心跳，并且在上报心跳的同时会对所有实例是否上报心跳进行探测，如果某个实例不上报心跳了，之前的任务就被接管，接管的逻辑和获取新任务的逻辑类似，不再赘述</p>
<pre tabindex="0"><code>//定时上报心跳
func Heartbeat() {
    for {
        heartbeat()
        time.Sleep(time.Second)
    }
}

//
dss, err := models.DeadTasSchedulers()
if err != nil {
    logger.Errorf(&#34;cannot get dead task schedulers: %v&#34;, err)
    return
}

cnt := len(dss)
if cnt == 0 {
    return
}

for i := 0; i &lt; cnt; i++ {
    ids, err := models.TasksOfScheduler(dss[i])
    if err != nil {
        logger.Errorf(&#34;cannot get tasks of scheduler(%s): %v&#34;, dss[i], err)
        return
    }
    if len(ids) == 0 {
        err = models.DelDeadTaskScheduler(dss[i])
        if err != nil {
            logger.Errorf(&#34;cannot del dead task scheduler(%s): %v&#34;, dss[i], err)
            return
        }
    }
    takeOverTasks(ident, dss[i], ids)
}
</code></pre><p><strong>3..如何保证任务不被重复执行？</strong></p>
<p>当 agent 执行完任务之后，由于网络问题或者调度任务的服务端实例挂了，都会导致服务端感知不到任务已经执行完成了，会再次进行任务的下发，那 agent 如何避免任务被再次执行呢？对应执行完的任务，agent 会把执行结果持久化到磁盘，agent 在执行任务的之前，会检测待执行的任务之前是否执行过，如果之前执行过了，会直接返回结果，不在重复执行，下面是主要的实现逻辑</p>
<pre tabindex="0"><code>if resp.AssignTasks != nil {
    count := len(resp.AssignTasks)
    for i := 0; i &lt; count; i++ {
        at := resp.AssignTasks[i]
        assigned[at.Id] = struct{}{}
        Locals.AssignTask(at)
    }
}

func (lt *LocalTasksT) AssignTask(at dataobj.AssignTask) {
    local, found := lt.GetTask(at.Id)
    //...
        if local.doneBefore() {
            local.loadResult()
            return
        }
    //...
}

//任务完成之后，落盘记录
func persistResult(t *Task) {
    metadir := config.Config.Job.MetaDir

    stdout := path.Join(metadir, fmt.Sprint(t.Id), &#34;stdout&#34;)
    stderr := path.Join(metadir, fmt.Sprint(t.Id), &#34;stderr&#34;)
    doneFlag := path.Join(metadir, fmt.Sprint(t.Id), fmt.Sprintf(&#34;%d.done&#34;, t.Clock))

    file.WriteString(stdout, t.GetStdout())
    file.WriteString(stderr, t.GetStderr())
    file.WriteString(doneFlag, t.GetStatus())
}
</code></pre><h3 id="二次开发demo">二次开发demo</h3>
<p>任务执行中心在机器上提供了一种命令通道的能力，基于任务执行中心可以开发适合自己公司的机器初始化、服务发布变更、故障自愈等系统。下面以构建服务发布变更举例，介绍如何基于任务执行中心进行二次开发</p>
<p>如果要做一个变更发布系统，我们通常需要关注一下几点</p>
<ol>
<li>需要支持灰度发布</li>
<li>需要支持随时暂停发布任务</li>
<li>需要支持快速回滚</li>
</ol>
<p>这能能力任务执行中心都已经具备了，所以基于任务执行中心开发变更发布系统非常方便，只需要维护一些元信息，然后调用任务管理的接口即可</p>
<pre tabindex="0"><code>    //创建任务
userLogin.POST(&#34;/tasks&#34;, taskPost)

//更新任务的状态
userLogin.PUT(&#34;/task/:id/action&#34;, taskActionPut)

//查看任务的执行情况
notLogin.GET(&#34;/task/:id/stdout&#34;, taskStdout)
notLogin.GET(&#34;/task/:id/stderr&#34;, taskStderr)
notLogin.GET(&#34;/task/:id/state&#34;, apiTaskState)
notLogin.GET(&#34;/task/:id/result&#34;, apiTaskResult)
</code></pre><p>拿实现发布系统的上线功能举例</p>
<pre tabindex="0"><code>//创建一个 jobMeta 的数据结构
type JobMeta struct {
    Title     string   `json:&#34;title&#34;`
    Account   string   `json:&#34;account&#34;`   //设置执行账号
    Batch     int      `json:&#34;batch&#34;`     //并发度控制
    Tolerance int      `json:&#34;tolerance&#34;` //暂停点，实现灰度功能要用到这个字段
    Timeout   int64    `json:&#34;timeout&#34;`   //部署超时时间
    Pause     string   `json:&#34;pause&#34;`     //暂停点，实现灰度功能要用到这个字段
    Script    string   `json:&#34;script&#34;`    //发布系统，执行发布任务的脚本
    Args      string   `json:&#34;args&#34;`        //执行脚本需要的参数
    Action    string   `json:&#34;action&#34;`    //待执行的动作，支持 ignore|pause|kill|redo
    Hosts     []string `json:&#34;hosts&#34;`     //待执行的机器
}

func main() {
    http.Start()
}

func httpConfig(r *gin.Engine) {
    demo := r.Group(&#34;/api/&#34;)
      {
           demo.POST(&#34;/deploy&#34;, createDepoly)
      }   
}

func createDepoly(c *gin.Context) {
    userName := loginUsername(c)
    var jobMeta  JobMeta
    c.ShouldBindJSON(&amp;jobMeta)
    
    data, err := json.Marshal(jobDat)
    errors.Dangerous(err)
    
    httplib.PostJSON(&#34;job.addr/api/job-ce/tasks&#34;, time.Second*5, data, nil)
    renderData(c, nil, err)
}
</code></pre><p>只要我们准备好发布服务需要执行的脚本文件，然后在每次发布服务的时候，将 jobMeta 根据需求补充完整，这样再实现一个web页面，一个简单发布系统就实现了。当然想要投入到生产环境使用，还需要在高可用方面在做一些工作。</p>
<p>本篇是夜莺二次开发系列的最后一篇，希望本系列可以给大家带来一些帮助。</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="http://www.qinyening.com/">秦叶宁</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="http://www.qinyening.com/post/2020-12-24-n9e-dev6/">http://www.qinyening.com/post/2020-12-24-n9e-dev6/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/%E7%9B%91%E6%8E%A7'>监控</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div class="container">
      &copy; 2025 <a rel="nofollow" href="http://www.qinyening.com/">秦叶宁的网志</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io">Hugo</a> &amp; <a rel="nofollow noreferer noopener" href="https://github.com/flysnow-org/maupassant-hugo">maupassant theme</a>.
    </div>
</footer>

<script type="text/javascript" src="/js/app.js" defer></script>


<script type="text/javascript" src="/js/douban.js" defer></script>
<script type="text/javascript" src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' defer></script>
                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='http://www.qinyening.com/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://www.qinyening.com/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://www.qinyening.com/post/2021-11-17-stability/" title="运维体系建设思考-稳定性篇">运维体系建设思考-稳定性篇</a>
    </li>
    
    <li>
        <a href="http://www.qinyening.com/post/2020-12-24-n9e-dev6/" title="夜莺二次开发指南-任务执行中心">夜莺二次开发指南-任务执行中心</a>
    </li>
    
    <li>
        <a href="http://www.qinyening.com/post/2020-12-24-n9e-dev4/" title="夜莺二次开发指南-用户资源中心">夜莺二次开发指南-用户资源中心</a>
    </li>
    
    <li>
        <a href="http://www.qinyening.com/post/2020-12-24-n9e-dev5/" title="夜莺二次开发指南-资产设备管理">夜莺二次开发指南-资产设备管理</a>
    </li>
    
    <li>
        <a href="http://www.qinyening.com/post/2020-12-24-n9e-dev3/" title="夜莺二次开发指南-监控系统（3）">夜莺二次开发指南-监控系统（3）</a>
    </li>
    
    <li>
        <a href="http://www.qinyening.com/post/2020-12-24-n9e-dev2/" title="夜莺二次开发指南-监控系统（2）">夜莺二次开发指南-监控系统（2）</a>
    </li>
    
    <li>
        <a href="http://www.qinyening.com/post/2020-12-24-n9e-dev1/" title="夜莺二次开发指南-监控系统（1）">夜莺二次开发指南-监控系统（1）</a>
    </li>
    
    <li>
        <a href="http://www.qinyening.com/post/2019-06-29-monitor01/" title="企业监控平台建设-需求分析篇">企业监控平台建设-需求分析篇</a>
    </li>
    
    <li>
        <a href="http://www.qinyening.com/post/2017-08-27-deep-work/" title="职业思考：深度工作">职业思考：深度工作</a>
    </li>
    
    <li>
        <a href="http://www.qinyening.com/post/2016-08-07-urlooker/" title="Urlooker：Web 可用性监控系统">Urlooker：Web 可用性监控系统</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="http://www.qinyening.com/categories/IT%E6%8A%80%E6%9C%AF/">IT技术 (3)</a></li>
    
    <li><a href="http://www.qinyening.com/categories/%E8%AE%A4%E7%9F%A5%E7%A7%91%E5%AD%A6/">认知科学 (1)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="http://www.qinyening.com/tags/%E5%AE%89%E5%85%A8/">安全</a>
    
    <a href="http://www.qinyening.com/tags/%E7%9B%91%E6%8E%A7/">监控</a>
    
    <a href="http://www.qinyening.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
    
    <a href="http://www.qinyening.com/tags/%E9%9A%8F%E6%83%B3/">随想</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://blog.x2know.org" title="秦叶宁的网志">秦叶宁的网志</a>
        </li>
        
        <li>
            <a target="_blank" href="https://www.yangzhiping.com/" title="阳志平的网志">阳志平的网志</a>
        </li>
        
        <li>
            <a target="_blank" href="https://www.v2ex.com/go/create" title="V2EX">V2EX</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="http://www.qinyening.com/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>